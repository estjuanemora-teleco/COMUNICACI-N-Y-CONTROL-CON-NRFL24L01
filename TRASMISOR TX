from machine import Pin, SPI, I2C, ADC
from time import sleep
from nrf24l01 import NRF24L01

# CONFIGURACI√ìN MPU6050
MPU_ADDR = 0x68
i2c = I2C(0, scl=Pin(5), sda=Pin(0), freq=400000)
i2c.writeto_mem(MPU_ADDR, 0x6B, b'\x00')

def leer_acelerometro():
    try:
        data = i2c.readfrom_mem(MPU_ADDR, 0x3B, 6)
        x = (data[0] << 8 | data[1])
        y = (data[2] << 8 | data[3])
        z = (data[4] << 8 | data[5])
        if x > 32767: x -= 65536
        if y > 32767: y -= 65536
        if z > 32767: z -= 65536
        return x / 16384, y / 16384, z / 16384
    except OSError:
        return 0, 0, 0

# CONFIGURACI√ìN JOYSTICK
xAxis = ADC(Pin(27))
yAxis = ADC(Pin(26))
button = Pin(17, Pin.IN, Pin.PULL_UP)

def leer_joystick():
    x = xAxis.read_u16()
    y = yAxis.read_u16()
    b = 0 if button.value() == 0 else 1
    return x, y, b

# CONFIGURACI√ìN NRF24L01
spi = SPI(0, sck=Pin(6), mosi=Pin(7), miso=Pin(4))
csn = Pin(14, Pin.OUT, value=1)
ce = Pin(15, Pin.OUT, value=0)
nrf = NRF24L01(spi, csn, ce, payload_size=32)

address = b"00001"
nrf.open_tx_pipe(address)
nrf.stop_listening()

print("üì° Transmisor listo ‚Äî enviando √°ngulo + aceler√≥metro")

while True:
    ax, ay, az = leer_acelerometro()
    jx, jy, jb = leer_joystick()

    # Convertir joystick a √°ngulo (0-180)
    angulo = int((jx / 65535) * 180)
    angulo = max(0, min(180, angulo))
    
    # FORMATO CORREGIDO - SIN ERRORES
    msg = f"ANG:{angulo}|A:{ax:.2f},{ay:.2f},{az:.2f}"
    msg_bytes = msg.encode()[:32]
    
    try:
        nrf.send(msg_bytes)
        print(f"üì§ Angulo: {angulo}¬∞ | Accel: {ax:.2f},{ay:.2f},{az:.2f}")
    except OSError:
        print("‚ö†Ô∏è Error al enviar")

    sleep(0.01)
